{% extends "base.html" %}

{% block title %}メイン画面{% endblock %}
{% block header %}メイン画面{% endblock %}

{% block content %}
{% if message %}
<div class="notification is-info">{{ message }}</div>
{% endif %}

<div class="box">
  <p class="mb-2">選択中のシリアルポート: {{ settings.serial_port or "未設定" }}</p>
  <p class="mb-4">ボーレート: {{ settings.baud_rate }}, パリティ: {{ settings.parity }}, ストップビット: {{ settings.stop_bits }}</p>
</div>

<form method="post" action="/transmit" class="box">
  <div class="field">
    <label class="label" for="payload">送信データ</label>
    <div class="control">
      <textarea class="textarea" id="payload" name="payload" placeholder="コマンドを入力してください"></textarea>
    </div>
  </div>
  <div class="field">
    <div class="control">
      <button class="button is-primary" type="submit">送信</button>
    </div>
  </div>
</form>

<div class="box">
  <h2 class="title is-5">音声ストリーム</h2>
  <audio id="audio-player" controls autoplay playsinline class="mb-3"></audio>
  <div class="buttons">
    <button class="button is-link" id="connect-btn">再生開始</button>
    <button class="button" id="disconnect-btn">再生停止</button>
  </div>
  <p id="playback-status" class="has-text-grey">未接続</p>
</div>

<div class="box">
  <h2 class="title is-5">音声送信</h2>
  <div class="buttons">
    <button class="button is-primary" id="uplink-start">送信開始</button>
    <button class="button" id="uplink-stop">送信停止</button>
  </div>
  <p id="uplink-status" class="has-text-grey">未送信</p>
</div>

<script>
  (() => {
    const sessionUrl = "{{ webrtc_session_url }}";
    const audioEl = document.getElementById("audio-player");
    const connectBtn = document.getElementById("connect-btn");
    const disconnectBtn = document.getElementById("disconnect-btn");
    const playbackStatus = document.getElementById("playback-status");
    const uplinkStartBtn = document.getElementById("uplink-start");
    const uplinkStopBtn = document.getElementById("uplink-stop");
    const uplinkStatus = document.getElementById("uplink-status");

    let pc = null;
    let sessionId = null;
    let localStream = null;
    let micSender = null;

    function updatePlaybackStatus(text, level = "info") {
      playbackStatus.textContent = text;
      playbackStatus.className = level === "error" ? "has-text-danger" : "has-text-grey";
    }

    function updateUplinkStatus(text, level = "info") {
      uplinkStatus.textContent = text;
      uplinkStatus.className = level === "error" ? "has-text-danger" : "has-text-grey";
    }

    async function negotiate() {
      if (!pc) {
        return;
      }
      const offer = await pc.createOffer();
      await pc.setLocalDescription(offer);

      const response = await fetch(sessionUrl, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          sdp: pc.localDescription.sdp,
          type: pc.localDescription.type,
          session_id: sessionId,
        }),
      });

      if (!response.ok) {
        throw new Error("シグナリングに失敗しました");
      }

      const answer = await response.json();
      sessionId = answer.session_id;
      await pc.setRemoteDescription(answer);
    }

    async function startConnection() {
      if (pc) {
        updatePlaybackStatus("既に接続済みです");
        return;
      }

      pc = new RTCPeerConnection({
        bundlePolicy: "max-bundle",
        rtcpMuxPolicy: "require",
      });

      pc.ontrack = (event) => {
        if (event.track.kind === "audio") {
          const [stream] = event.streams;
          audioEl.srcObject = stream;
        }
      };

      pc.onconnectionstatechange = () => {
        if (!pc) return;
        if (pc.connectionState === "failed") {
          updatePlaybackStatus("接続に失敗しました", "error");
        } else if (pc.connectionState === "connected") {
          updatePlaybackStatus("再生中");
        }
      };

      try {
        await negotiate();
        updatePlaybackStatus("再生中");
      } catch (error) {
        console.error(error);
        updatePlaybackStatus("接続に失敗しました", "error");
        await stopConnection();
      }
    }

    async function stopConnection() {
      await stopUplink();
      sessionId = null;

      if (pc) {
        pc.getSenders().forEach((sender) => {
          try {
            pc.removeTrack(sender);
          } catch (_) {
            // ignore
          }
        });
        pc.close();
        pc = null;
      }

      if (audioEl.srcObject) {
        audioEl.srcObject.getTracks().forEach((track) => track.stop());
        audioEl.srcObject = null;
      }
      updatePlaybackStatus("未接続");
    }

    async function startUplink() {
      if (!pc) {
        updatePlaybackStatus("先に再生を開始してください", "error");
        return;
      }

      if (micSender) {
        updateUplinkStatus("送信中");
        return;
      }

      try {
        localStream = await navigator.mediaDevices.getUserMedia({ audio: true });
      } catch (error) {
        console.error(error);
        updateUplinkStatus("マイクの使用が許可されません", "error");
        return;
      }

      const [track] = localStream.getAudioTracks();
      micSender = pc.addTrack(track, localStream);
      updateUplinkStatus("送信準備中...");
      try {
        await negotiate();
        updateUplinkStatus("送信中");
      } catch (error) {
        console.error(error);
        updateUplinkStatus("送信開始に失敗しました", "error");
      }
    }

    async function stopUplink() {
      if (micSender && pc) {
        try {
          pc.removeTrack(micSender);
        } catch (_) {
          // ignore
        }
        micSender = null;
        try {
          await negotiate();
        } catch (error) {
          console.error(error);
        }
      }

      if (localStream) {
        localStream.getTracks().forEach((track) => track.stop());
        localStream = null;
      }
      updateUplinkStatus("未送信");
    }

    connectBtn.addEventListener("click", (event) => {
      event.preventDefault();
      startConnection();
    });

    disconnectBtn.addEventListener("click", async (event) => {
      event.preventDefault();
      await stopConnection();
    });

    uplinkStartBtn.addEventListener("click", async (event) => {
      event.preventDefault();
      await startUplink();
    });

    uplinkStopBtn.addEventListener("click", async (event) => {
      event.preventDefault();
      await stopUplink();
    });

    window.addEventListener("beforeunload", async () => {
      await stopConnection();
    });
  })();
</script>
{% endblock %}
