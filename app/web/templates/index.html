{% extends "base.html" %}

{% block title %}メイン画面{% endblock %}
{% block header %}メイン画面{% endblock %}

{% block content %}
{% if message %}
<div class="notification is-info">{{ message }}</div>
{% endif %}

<div class="box">
  <p class="mb-2">選択中のシリアルポート: {{ settings.serial_port or "未設定" }}</p>
  <p class="mb-4">ボーレート: {{ settings.baud_rate }}, パリティ: {{ settings.parity }}, ストップビット: {{ settings.stop_bits }}</p>
</div>

<form method="post" action="/transmit" class="box">
  <div class="field">
    <label class="label" for="payload">送信データ</label>
    <div class="control">
      <textarea class="textarea" id="payload" name="payload" placeholder="コマンドを入力してください"></textarea>
    </div>
  </div>
  <div class="field">
    <div class="control">
      <button class="button is-primary" type="submit">送信</button>
    </div>
  </div>
</form>

<div class="box">
  <h2 class="title is-5">音声ストリーム</h2>
  <div class="buttons">
    <button class="button is-link" id="audio-start">再生</button>
    <button class="button" id="audio-stop">停止</button>
  </div>
  <p id="audio-status" class="has-text-grey">未接続</p>
</div>

<script>
  (() => {
    const wsUrl = "{{ audio_ws_url }}";
    const sampleRate = {{ audio_sample_rate }};
    const workletUrl = "{{ audio_worklet_url }}";

    const startBtn = document.getElementById("audio-start");
    const stopBtn = document.getElementById("audio-stop");
    const statusEl = document.getElementById("audio-status");

    const bufferQueue = [];
    const prebufferSamples = Math.round(sampleRate * 0.6); // 約600msぶん確保
    const maxBufferedSamples = Math.round(sampleRate * 2.5); // 約2.5秒で頭打ち

    let audioContext = null;
    let workletNode = null;
    let websocket = null;
    let workletReady = false;
    let playbackReady = false;
    let bufferedSamples = 0;

    function updateStatus(text, level = "info") {
      statusEl.textContent = text;
      statusEl.className = level === "error" ? "has-text-danger" : "has-text-grey";
    }

    function connect() {
      if (websocket && websocket.readyState === WebSocket.OPEN) {
        return;
      }

      const targetUrl =
        wsUrl.startsWith("ws") || wsUrl.startsWith("wss")
          ? wsUrl
          : wsUrl.replace("http", "ws");

      websocket = new WebSocket(targetUrl);
      websocket.binaryType = "arraybuffer";

      websocket.onopen = () => updateStatus("接続中...");
      websocket.onclose = () => {
        updateStatus("未接続");
        stopAudio();
      };
      websocket.onerror = () => updateStatus("通信エラーが発生しました", "error");
      websocket.onmessage = (event) => {
        if (!workletNode) {
          return;
        }
        const int16 = new Int16Array(event.data);
        const float32 = new Float32Array(int16.length);
        for (let i = 0; i < int16.length; i += 1) {
          float32[i] = int16[i] / 32768;
        }
        enqueueChunk(float32);
      };
    }

    async function ensureAudioContext() {
      if (!audioContext) {
        audioContext = new (window.AudioContext || window.webkitAudioContext)({
          sampleRate,
        });
      }

      if (!workletReady) {
        await audioContext.audioWorklet.addModule(workletUrl);
        workletNode = new AudioWorkletNode(audioContext, "pcm-player-processor", {
          outputChannelCount: [1],
        });
        workletNode.connect(audioContext.destination);
        workletReady = true;
        playbackReady = false;
      }

      if (audioContext.state === "suspended") {
        await audioContext.resume();
      }
    }

    async function startAudio() {
      try {
        await ensureAudioContext();
      } catch (error) {
        console.error(error);
        updateStatus("オーディオ初期化に失敗しました", "error");
        return;
      }

      connect();
      updateStatus("再生中");
    }

    function stopAudio() {
      clearBuffers();

      if (workletNode) {
        workletNode.disconnect();
        workletNode = null;
        workletReady = false;
      }

      if (audioContext && audioContext.state !== "closed") {
        audioContext.suspend();
      }

      if (websocket && websocket.readyState === WebSocket.OPEN) {
        websocket.close(1000, "client stop");
      }
    }

    startBtn.addEventListener("click", async (event) => {
      event.preventDefault();
      await startAudio();
    });

    stopBtn.addEventListener("click", (event) => {
      event.preventDefault();
      stopAudio();
      updateStatus("停止しました");
    });

    window.addEventListener("beforeunload", () => {
      stopAudio();
      if (audioContext) {
        audioContext.close();
      }
    });

    function enqueueChunk(float32) {
      bufferQueue.push({ data: float32, length: float32.length });
      bufferedSamples += float32.length;

      if (bufferedSamples > maxBufferedSamples) {
        // Drop oldest chunk to keep latency bounded
        const dropped = bufferQueue.shift();
        if (dropped) {
          bufferedSamples -= dropped.length;
        }
      }

      if (!playbackReady) {
        const progress = Math.min(
          99,
          Math.round((bufferedSamples / prebufferSamples) * 100)
        );
        updateStatus(`バッファリング中... ${progress}%`);
        if (bufferedSamples >= prebufferSamples) {
          playbackReady = true;
          updateStatus("再生中");
        } else {
          return;
        }
      }

      flushBufferQueue();
    }

    function flushBufferQueue() {
      if (!workletNode) {
        return;
      }
      while (bufferQueue.length > 0) {
        const chunk = bufferQueue.shift();
        if (!chunk) {
          break;
        }
        bufferedSamples -= chunk.length;
        workletNode.port.postMessage({ samples: chunk.data.buffer }, [
          chunk.data.buffer,
        ]);
      }
    }

    function clearBuffers() {
      bufferQueue.length = 0;
      bufferedSamples = 0;
      playbackReady = false;
    }
  })();
</script>
{% endblock %}
